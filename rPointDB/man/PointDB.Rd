% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/PointDB.R
\name{PointDB}
\alias{PointDB}
\title{PointDB class}
\format{
RasterDB \link{R6Class} object.
}
\usage{
remotesensing <- RemoteSensing$new(url, userpwd=NULL)
pointdb <- remotesensing$pointdb(name)

pointdb$query(ext, filter=NULL, columns=NULL, normalise=NULL)
pointdb$query_polygon(polygon, filter=NULL, columns=NULL, normalise=NULL)
pointdb$query_raster(ext, type)
pointdb$process(areas, functions)

pointdb$info
pointdb$processing_functions
pointdb$raster_processing_types
pointdb$roi_groups
pointdb$poi_groups
}
\description{
PointDB class provides methods to access (LiDAR) point-clouds of Remote Sensing Database.
}
\section{Details}{


In the Following methods of PointDB are described. Use instance objects to call that methods (e.g. pointdb$method(paramters) ).
Use instance of \link{RemoteSensing} class to create instances of PointDB.

\describe{

\item{$query(ext, filter=NULL, columns=NULL, normalise=NULL)}{Send query with exent rectangle to database and receive result as data.frame.

returns data.frame of points. See section \code{query data.frame} for details.}

\item{$query_polygon(polygon, filter=NULL, columns=NULL, normalise=NULL)}{Send query with polygon to database and receive result as data.frame.

polygon is of class "Polygons" or "Polygon" or "Matrix"

if polygon is matrix: one row per polygon vertex and two columns with x- and y-coordinates.

Polygons may be received by remotesensing$roi(...) or remotesensing$roi_group(...).

returns data.frame of points. See section \code{query data.frame} for details.}

\item{$query_raster(ext, type)}{Query processing of LiDAR points as RasterLayer.
See section \code{query raster} for details.}

\item{$process(areas, functions)}{Send (index) processing request of areas to database and receive result as data.frame.
See section \code{Process} for details.}

\item{$info}{meta data of layer (e.g. coordinate reference system, extent).}

\item{$processing_functions}{data.frame of processing functions name and description}

\item{$raster_processing_types}{data.frame of raster processing type name and title}

\item{$roi_groups}{get names of ROI-groups that are associated with this PointDB.
Use \link{RemoteSensing} to load ROI-groups by name.

returns: data.frame of name and description}

\item{$poi_groups}{get names of POI-groups that are associated with this PointDB.
Use \link{RemoteSensing} to load POI-groups by name.

returns: data.frame of name and description}

}
}

\section{Query data.frame}{

A query of this type returns a data.frame with one row per LiDAR point.

Meta data is attached to resulting data.frame \code{df}:

\itemize{

 \item \strong{\code{attr(df,"proj4")}}

 coordinate reference system

}
}

\section{Coordinates}{

x and y values are in a project specific planar coordinate space.

z values are perpendicular to the x,y-plane. e.g. elevation above sea level in meter.

For queries parameter \code{ext} is an \code{\link{extent}} object which may be created by \code{ext <- \link{extent}(xmin,xmax,ymin,ymax)} or by \code{ext <- \link{extent_diameter}(x, y, diameter)} or by \code{ext <- \link{extent_radius}(x, y, radius)}
}

\section{Columns}{

The columns paramter is a character-vector or a list of character-vectors. It describes which columns should be contained in the data.frame.
The column-names have to be separated by comma. If no columns paramter is specified all columns are included in the data.frame.

Currently following columns are possible:

\itemize{
 \item \strong{x} coordinate.
 \item \strong{y} coordinate.
 \item \strong{z} coordinate.
 \item \strong{intensity} of returned laser pulse echo.
 \item \strong{returnNumber} number of returned echo of one laser pulse.
 \item \strong{returns} total number of returned echos of one laser pulse.
 \item \strong{scanAngleRank} angle in degrees of laser pulse relative to the perpendicular vector of x,y-plane. So a value of 0 degrees indicates that the laser beam exactly points in z-direction.
 \item \strong{classification} number value of classification type. The data source may not conatain classification data. Values of 0 and 1 denote unclassified points.
 \item \strong{classificationFlags} number that indicates some additional classification information.
}
example: \code{"x,y,intensity"} The data.frame should contain x and y coordinates and intensity values.
example: \code{c("x","y","z")} The data.frame should contain x, y and z coordinates.
}

\section{Filter}{

A filter is a character-vector or a list of character-vectors. It specifies which points of a given set of points should be returned in the data.frame.
Without a filter all points are returned.

\itemize{
 \item \strong{\code{"return=n"}}

 returns all points that are the n-th echo of one laser-pulse.

 example: filter="return=2" returns alle point that are the second echo.

 \item \strong{\code{"last_return=n"}}

 returns all points that are the n-th last echo of one laser-pulse.

 \item \strong{\code{"classification=n"}}

 returns all points that are classified n. Multiple classes are separated by _
 
 example: filter="classification=1" returns alle point that are of class 1.
 
 example: filter="classification=1_2_4" returns alle point that are of class 1 or 2 or 4.
}

Filters can be conjunctive combined with "\code{;}" separator or as elements of a list. Currently no spaces are allowed in the filter expressions.

example: \code{"last_return=1"} returns all points that are the last echo.

conjunctive example: \code{c("classification=2","last_return=1")} returns all points that are of class 2 and last return.
}

\section{Normalise}{

Parameter \code{normalise} transformes LiDAR points for normalisation purposes.

\itemize{

 \item \strong{\code{"origin"}}

 moves (x,y) coordinates of points to origin (0,0) by moving the query extent lowest coordinate to (0,0). This normalisation may be usefull to have smaller (x,y) coordinate values and to compare different queries.

 \item \strong{\code{"extremes"}}

 removes LiDAR points that are outliers in z resp. elevation coordinate

 \item \strong{\code{"ground"}}

 moves z resp. elevation coordinate of LiDAR points to elevation zero. The resulting z coordinates represent vegetation above ground.

}

Multiple Normalisations may be combined by list of characters or by comma separated character. e.g. \code{"origin,extremes"} or \code{list("extremes","ground")}
}

\section{Query raster}{

A query of this type processes LiDAR points and returns a RasterLayer (or RasterBrick).

Parameter 'type' determines processing method.

All available types can be listed by pontdb property raster_processing_types (e.g. 'pointdb$raster_processing_types').

Type Description:

\itemize{

\item \strong{\code{DTM}}

Digital Terrain Model: ground surface without vegetation

\item \strong{\code{DSM}}

Digital Surface Model: surface including vegetation

\item \strong{\code{CHM}}

Canopy Height Model: surface of vegetation above ground (with local ground normalised to height zero). "DSM minus DTM"

\item \strong{\code{DTM_slope}}

Slope of DTM.

\item \strong{\code{DSM_slope}}

Slope of DSM.

\item \strong{\code{CHM_slope}}

Slope of CHM.

\item \strong{\code{voxel}}

point count per voxel (1x1x1 meter cube)
returns RasterBrick with one RasterLayer per one meter height (one slice of voxels of one height step)

}

Meta data is attached to resulting raster \code{r}:

\itemize{

 \item \strong{\code{r@crs}}

 coordinate reference system

 \item \strong{\code{r@extent}}

 geographic \code{\link{extent}}

 \item \strong{\code{r@ncols}} and \strong{\code{r@nrows}}

 extent in raster pixels

 \item \strong{\code{names(r)}}

 name of this raster may contain processing information.

}
}

\section{Process}{


Process applies functions to each area and returns results as data.frame.

\strong{Parameter areas:}

areas is of type \strong{SpatialPolygons}, \strong{SpatialPolygonsDataFrame} or of type \strong{list}:

SpatialPolygons or SpatialPolygonsDataFrame:

Polygons are extracted with IDs as names. See details of conversion in \link{convert_SpatialPolygonsDataFrame_to_named_matrix_list}

List of Polygons:

Polygons are extracted with names (if list elements are named). . See details of conversion in \link{convert_Polygons_to_matrix}

List of Polygon:

Polygons are extracted with names (if list elements are named). . See details of conversion in \link{convert_Polygon_to_matrix}


List of Extent:

Polygons are extracted as rectangles and with names (if list elements are named)

List of Matrix:

Polygons are extracted as polygons and with names (if list elements are named), matrix of two columns (x,y) and one row per point, first and last point need to be same for closed polygons.

Example create three areas with names a1, a2, a3 of rectangle, square, triangle:

\code{
areas <- list(
   a1=extent(x=1000, ymin=3000, xmax=1010, ymax=3005),
   a2=extent_diameter(x=1200, y=3100, 10),
   a3=matrix(c(10,71,12,71,12,72,11,71), ncol=2, byrow=TRUE)
)
}

Example create areas of all ROIs in a ROI-group:

\code{rois <- remotesensing$roi_group(group_name="kili_A")}

\code{areas <- rois$polygon}

Example create areas of all POIs in a POI-group with 10 meter squares:

\code{pois <- remotesensing$poi_group(group_name="kili")}

\code{areas <- mapply(function(name, x, y) {return(extent_diameter(x, y, 10))}, pois$name, pois$x, pois$y)}

\strong{Parameter functions:}

A vector or list of function names.

Example some functions: \code{functions <- c("BE_H_MAX", "BE_H_P20", "pulse_density")}

Example all functions: \code{functions <- pointdb$processing_functions$name}

\strong{Returns:}

A data.frame with one row per area and one column per function (first column wih area names).

Areas are named with names of the named areas-paramter or if areas-parameter is not named with ascending numbers.

Areas that are not covered by LiDAR points are not included in result.
}

\examples{
# open remote sensing database
library(rPointDB)
# remotesensing <- RemoteSensing$new("http://localhost:8081", "user:password") # local
remotesensing <- RemoteSensing$new("http://example.com:8081", "user:password") # remote server

# get names of PointDBs
remotesensing$pointdbs

# get one pointdb
pointdb <- remotesensing$pointdb("kili")

# get names of ROI groups associated with this PointDB
pointdb$roi_groups

# get names of POI groups associated with this PointDB
pointdb$poi_groups

# get meta data of PointDB
pointdb$info

# get one ROI group
rois <- remotesensing$roi_group("kili_A")

# get one ROI
roi <- remotesensing$roi(group_name="kili_A", roi_name="cof3_A")

# get one POI group
pois <- remotesensing$poi_group("kili")

# get one POI
poi <- remotesensing$poi(group_name="kili", poi_name="cof3")

# get points of point-cloud that are covered by polygon cof3_A
df <- pointdb$query_polygon(roi$polygon[[1]])
library(rgl)
plot3d(df$x, df$y, df$z)

# create extent around poi of 10 meter edge length
ext <- extent_diameter(poi$x, poi$y, 10)

# get points of point-cloud that are covered by ext,
# with last return only, just x,y,z coordinates and x,y moved to origin of ext
df <- pointdb$query(ext, filter="last_return=1", columns=c("x","y","z"), normalise="origin")
library(rgl)
plot3d(df$x, df$y, df$z)

# get RasterLayer of ext, processed as DTM
r <- pointdb$query_raster(ext, "dtm")
plot(r)
visualise_raster(r)

}
\seealso{
\link{RemoteSensing} \link{extent} \link{extent_diameter} \link{extent_radius} \link{RasterLayer-class} \link{visualise_raster}
}
\author{
woellauer
}
\keyword{LiDAR}
\keyword{database}
\keyword{point}
\keyword{point-cloud}
\keyword{remote-sensing}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{PointDB$new()}}
\item \href{#method-process}{\code{PointDB$process()}}
\item \href{#method-query}{\code{PointDB$query()}}
\item \href{#method-query_polygon}{\code{PointDB$query_polygon()}}
\item \href{#method-query_raster}{\code{PointDB$query_raster()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PointDB$new(url, db, curlHandle, rsdbConnector)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-process"></a>}}
\if{latex}{\out{\hypertarget{method-process}{}}}
\subsection{Method \code{process()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PointDB$process(areas, functions)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-query"></a>}}
\if{latex}{\out{\hypertarget{method-query}{}}}
\subsection{Method \code{query()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PointDB$query(ext, filter = NULL, columns = NULL, normalise = NULL)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-query_polygon"></a>}}
\if{latex}{\out{\hypertarget{method-query_polygon}{}}}
\subsection{Method \code{query_polygon()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PointDB$query_polygon(polygon, filter = NULL, columns = NULL, normalise = NULL)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-query_raster"></a>}}
\if{latex}{\out{\hypertarget{method-query_raster}{}}}
\subsection{Method \code{query_raster()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PointDB$query_raster(ext, type)}\if{html}{\out{</div>}}
}

}
}
