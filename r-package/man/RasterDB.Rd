% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RasterDB.R
\name{RasterDB}
\alias{RasterDB}
\title{RasterDB class}
\format{
RasterDB \link{R6Class} object.
}
\usage{
remotesensing <- RemoteSensing$new(url, userpwd=NULL)
rasterdb <- remotesensing$rasterdb(name)

raster_stack <- rasterdb$raster(ext, time_slice=NULL, band=NULL, product=NULL, masking='center', timestamp=NULL)
rasterdb$insert_RasterLayer(r, time_slice=NULL, band=1, band_title=NULL, flush=TRUE, update_pyramid=TRUE, refresh_meta=TRUE, timestamp=NULL)
rasterdb$insert_RasterStack(r, time_slice=NULL, bands=NULL, flush=TRUE, update_pyramid=TRUE, refresh_meta=TRUE, timestamp=NULL)
rasterdb$refresh_meta()
rasterdb$update_pyramid()
rasterdb$set_meta(meta)
rasterdb$set_band_meta(bands)

rasterdb$name
rasterdb$time_slices
rasterdb$bands
rasterdb$pixel_size
rasterdb$extent
rasterdb$geo_code
rasterdb$proj4
rasterdb$description
rasterdb$timestamps
}
\description{
RasterDB class provides methods to access (hyperspectral) rasters of Remote Sensing Database.
}
\section{Details}{


In the Following methods of RasterDB are described. Use instance objects to call that methods (e.g. rasterdb$method(paramters) ).
Use instance of \link{RemoteSensing} class to create instances of RasteDB.

\describe{

\item{remotesensing$rasterdb(name)}{Open existing raster with given name in Remote Sensing Database. This is the only method that needs a \link{RemoteSensing} instance.

name: Name of RasterDB.

returns: RasterDB object}

\item{$raster(ext, time_slice=NULL, band=NULL, product=NULL, masking='center', timestamp=NULL)}{Request raster data from opened RasterDB layer.
If neither band nor product are specified all bands are returned; either band or product can be specified.

ext: object of one class:
\itemize{
 \item{\strong{raster::extent}  extent}
 \item{\strong{sf::st_bbox}  extent}
 \item{\strong{SpatialPolygons}  if masking=='center': polygon masked raster or if masking=='extent':  extent of polygon}
 \item{\strong{sfc_MULTIPOLYGON}  if masking=='center': polygon masked raster or if masking=='extent':  extent of polygon}
 \item{\strong{sfc_POLYGON}  if masking=='center': polygon masked raster or if masking=='extent':  extent of polygon}
}

time_slice: (optional) Point in time, has to match an existing time_slice on this RasterDB layer.

band: (optional) vector or single number of requested band numbers

product: (optional) character vector of requested product specification. See section product.

masking: (optional) if 'ext' parameter is an extent masking parameter is ignored.

\itemize{
 \item{\strong{'center'} raster is masked by polygon (in 'ext' parameter) for pixels that center is within the polygon, see \link[raster]{mask}}
 \item{\strong{'extent'}  just extent (in 'ext' parameter) is used, no masking}
}

timestamp: (optional) (obsolete, use time_slice) timestamp of requested raster data.
Timestamp format is in ISO 8601. Valid syntax is: YYYY-MM-DDThh:mm for exact timestamp (e.g. "2017-12-31T23:59")
or shortened versions (YYYY, YYYY-MM, YYYY-MM-DD, YYYY-MM-DDThh) (e.g. 2017-12).
When shortened version is used oldest data in layer within that timerange is returned.
Alternatively, when timestamp is an integer the timestamp is used as an internal timestamp-id to request data.

returns: RasterLayer or RasterStack}

\item{$insert_RasterLayer(r, time_slice=NULL, band=1, band_title=NULL, flush=TRUE, update_pyramid=TRUE, refresh_meta=TRUE, timestamp=NULL)}{Insert raster data from RasterLayer into RasterDB.

If projection and/or resolution information is missing in the RasterDB layer then it is inserted form the given raster.

r: inserted RasterLayer

time_slice: (optional) Point in time, free text, but ISO 8601 preferred, e.g. 2021-02.

band: (optional) integer band number, creates band if it does not exist

band_title: (optional) title of band, only applied for newly created band

flush: (optional) ensure that all data is persisted on disc when this call returns.

update_pyramid: (optional) update pyramid with the new raster data.

refresh_meta: (optional) load updated metadata in R.

timestamp: (optional) (obsolete) integer representation of point in time, 0 represents missing timestamp. Or as specified in method 'raster, e.g. "2017-12-31T23:59".

returns: success message}

\item{insert_RasterStack(r, time_slice=NULL, bands=NULL, flush=TRUE, update_pyramid=TRUE, refresh_meta=TRUE, timestamp=NULL)}{Insert raster data from RasterStack into RasterDB.

If projection and/or resolution information is missing in the RasterDB layer then it is inserted form the given raster.

r: inserted RasterStack

time_slice: (optional) Point in time, free text, but ISO 8601 preferred, e.g. 2021-02.

bands: (optional) integer band numbers, creates bands if not existing

flush: (optional) ensure that all data is persisted on disc when this call returns.

update_pyramid: (optional) update pyramid with the new raster data.

refresh_meta: (optional) load updated metadata in R.

timestamp: (optional) (obsolete) integer representation of point in time, 0 represents missing timestamp. Or as specified in method 'raster, e.g. "2017-12-31T23:59".

returns: success message}

\item{$update_pyramid()}{(administrative method) Rebuild RasterDB internal pyramid of scaled rasters.

Note: This method processes all data in database and it may take a long time. Only use it if really needed.

returns: success message}

\item{$refresh_meta()}{Reload meta data of this raster layer from RSDB server.}

\item{$set_meta(meta)}{change meta data of this raster layer

 meta: named list of items to change:: 'title': Title of raster-layer, 'description', tags: 'list of raster-layer tags, acl: 'list read access roles', acl_mod: 'list modify access roles', properties: named list of info properties (from Dublin Core metadata standard, e.g. date.created, publisher)}

\item{$set_band_meta(bands)}{change band meta data of this raster layer

 bands: data.frame with band numbers in column 'index' and several of following meta data columns: 'datatype' 'title' 'wavelength' 'fwhm' 'visualisation' 'vis_min' 'vis_max'}

\item{$name}{ID of RasterDB}

\item{$time_slices}{data.frame of existing time_slices}

\item{$bands}{data.frame of band information (band index, wavelength, fwhm (wavelength bandwidth), title)}

\item{$pixel_size}{size of pixels in projection coordinates}

\item{$extent}{current full extent of this RasterDB.

Note: Don't use this extent directly for queries on RasterDB as it may be very large.}

\item{$geo_code}{geo code of projection. Typically this is an epsg code (e.g. "EPSG:32737")}

\item{$proj4}{PROJ.4 of projection. (e.g. "+proj=utm +zone=37 +south +datum=WGS84 +units=m +no_defs ")}

\item{$description}{description text)}

\item{$timestamps}{data.frame of timestamps}

}
}

\section{Product}{


Parameter product is a texual specification of raster processing request.

Syntax:
\describe{
\item{full_spectrum}{all bands that are part of (hyperspectral)-spectrum}
\item{bxxx}{band with numer xxx}
\item{rxxx}{band with approximate wavelenght xxx nanometer}
\item{[a, b, c]}{multiple bands a b c}
\item{[bxxx:byyy]}{all bands from index xxx to yyy}
\item{[rxxx:ryyy]}{all bands with wavelenght from xxx to yyy nanometer}
\item{[rxxx:ryyy, c]}{(combined) all bands with wavelenght from xxx to yyy and band c}
\item{a + x}{add to pixels of band a band x (or number x)}
\item{a - x}{substract to pixels of band a band x (or number x)}
\item{a * x}{multiply to pixels of band a band x (or number x)}
\item{a / x}{divide to pixels of band a band x (or number x)}
\item{(a + x) / (b * y)}{(combined) formula}
\item{ndvi}{vegetation index NDVI (Normalized Difference Vegetation Index)}
\item{evi}{vegetation index EVI (Enhanced vegetation index)}
\item{evi2}{vegetation index EVI2 (Two-band EVI)}
\item{savi}{vegetation index SAVI (Soil-Adjusted Vegetation Index)}
\item{normalised_difference(g, [a, b, c])}{normalise bands a b c by band g (method normalised difference: \code{(g - a) / (g + a)} )}
\item{normalised_ratio(g, [a, b, c])}{normalise bands a b c by band g (method ratio: \code{a / g} )}
\item{pca([a, b, c]) or pca([a, b, c], 2)}{PCA transform bands a b c (and return first 2 components)}
\item{euclidean_distance([a, b, c])}{distance from zero over all bands (euclidean distance: sqrt(a^2 + b2^2 + c^2) )}
\item{black_point_compensation([a, b, c])}{substract minimum value of each band (of current extent) ==> mimimum values are tranformed to zero ( [a - mina, b - minb, c - minc] )}
\item{gap_filling([a, b, c]) or gap_filling([a, b, c], 10) }{interpolate NA values with source pixels of maximum distance to target pixel of second parameter}
}

Examples:

band of number 2: \code{b2}

band of approximate wavelenght 650 nanometers: \code{r650}

three bands: \code{[r450, r460, r470]}

NDVI: \code{ndvi}

NDVI by formula: \code{(r800 - r680) / (r800 + r680)}

normalise bands of 600 to 700 nanometers by band at 800 nanometers: \code{normalised_difference(r800, [r600:r700])}
}

\section{RasterLayer / RasterStack Format}{


RasterLayer (one raster band) and RasterStack (multiple raster bands stored as multiple RasterLayer)
contain raster pixel values and additional information, that can be accessed by following commands:

\strong{RasterStack} r:
\describe{
\item{names(r)}{character vector of band titles}
\item{r@source}{source layer name of database}
\item{r@timestamp}{timestamp of received data (if present)}
\item{r@product}{product formula of processing (if present)}
\item{crs(r) or r@crs}{coordinate reference system as PROJ4 text}
\item{extent(r) or r@extent}{extent of raster in projection coordinates}
\item{xres(r)}{x resolution per pixel in projection coordinates}
\item{yres(r)}{y resolution per pixel in projection coordinates}
\item{res(r)}{x y resolution per pixel in projection coordinates}
\item{nlayers(r) or length(r@layers)}{count of layers (bands)}
\item{ncol(r) or r@ncols}{width in pixels}
\item{nrow(r) or r@nrows}{height in pixels}
\item{ncell(r)}{count of pixels per layer (width * height)}
\item{length(r)}{total count of pixels (layer_count * width * height)}
\item{dim(r)}{get width height layer_count}
\item{unstack(r) or r@layers}{list of RasterLayer}
\item{r@layers[[1]]}{first RasterLayer}
\item{as.vector(r)}{pixel values of all layers as numeric vector (layer1 row by row, layer2 row by row, ...)}
\item{as.vector(as.array(r))}{pixel values of all layers as numeric vector (pixel index 1 (layer by layer), pixel index 2 (layer by layer), ... with pixel index row by row)}
\item{values(r) or as.matrix(r)}{pixel values as matrix with first: pixel index (row by row), second: layer}
\item{as.array(r)}{pixel values as array of three dimensions with first: pixel row, second: pixel column, third: layer}
}

\strong{RasterLayer} r:
\describe{
\item{names(r) or r@data@names}{title of raster (band) e.g. for band 17 "b17"}
\item{r@source}{source layer name of database}
\item{r@timestamp}{timestamp of received data (if present)}
\item{r@product}{product formula of processing (if present)}
\item{r@index}{band number in RasterDB}
\item{crs(r) or r@crs}{coordinate reference system as PROJ4 text}
\item{extent(r) or r@extent}{extent of raster in projection coordinates}
\item{xres(r)}{x resolution per pixel in projection coordinates}
\item{yres(r)}{y resolution per pixel in projection coordinates}
\item{res(r)}{x y resolution per pixel in projection coordinates}
\item{r@wavelength}{wavelength in nanometer}
\item{r@fwhm}{wavelength bandwidth (full width at half maximum) nanometer}
\item{ncol(r) or r@ncols}{width in pixels}
\item{nrow(r) or r@nrows}{height in pixels}
\item{ncell(r) or length(r)}{count of pixels (width * height)}
\item{dim(r)}{get width height}
\item{values(r) or as.vector(r) or r@data@values}{pixel values as numeric vector (row by row)}
\item{as.matrix(r) or as.array(r)}{pixel values as matrix with first: pixel row, second: pixel column}
}
}

\examples{
# open remote sensing database
library(RSDB)
#remotesensing <- RemoteSensing$new("http://localhost:8081", "user:password") # local
remotesensing <- RemoteSensing$new("http://example.com:8081", "user:password") # remote server

# open RasterDB
rasterdb <- remotesensing$rasterdb("kili_campaign1")

# create extent
ext <- extent_dimateter(x=312062, y=9638537, d=10)

# request raster all bands from RasterDB
r <- rasterdb$raster(ext)
plot(r)

# request principal component analysis of bands up to wavelength 800 nm and return first 7 components.
r <- rasterdb$raster(ext, product="pca([r0:r800], 7)")
plot(r)

}
\seealso{
\link{RemoteSensing} \link{as.speclib} \link{extent} \link{extent_diameter} \link{extent_radius} \link{RasterLayer-class} \link{RasterStack-class}
}
\author{
woellauer
}
\keyword{band}
\keyword{database}
\keyword{hyperspectral}
\keyword{pixel}
\keyword{raster}
\keyword{remote-sensing}
\keyword{spectral}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-RasterDB-new}{\code{RasterDB$new()}}
\item \href{#method-RasterDB-refresh_meta}{\code{RasterDB$refresh_meta()}}
\item \href{#method-RasterDB-raster}{\code{RasterDB$raster()}}
\item \href{#method-RasterDB-insert_RasterLayer}{\code{RasterDB$insert_RasterLayer()}}
\item \href{#method-RasterDB-insert_RasterStack}{\code{RasterDB$insert_RasterStack()}}
\item \href{#method-RasterDB-rebuild_pyramid}{\code{RasterDB$rebuild_pyramid()}}
\item \href{#method-RasterDB-update_pyramid}{\code{RasterDB$update_pyramid()}}
\item \href{#method-RasterDB-set_meta}{\code{RasterDB$set_meta()}}
\item \href{#method-RasterDB-set_band_meta}{\code{RasterDB$set_band_meta()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-RasterDB-new"></a>}}
\if{latex}{\out{\hypertarget{method-RasterDB-new}{}}}
\subsection{Method \code{new()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{RasterDB$new(base_url, name, curlHandle, rsdbConnector)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-RasterDB-refresh_meta"></a>}}
\if{latex}{\out{\hypertarget{method-RasterDB-refresh_meta}{}}}
\subsection{Method \code{refresh_meta()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{RasterDB$refresh_meta()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-RasterDB-raster"></a>}}
\if{latex}{\out{\hypertarget{method-RasterDB-raster}{}}}
\subsection{Method \code{raster()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{RasterDB$raster(
  ext,
  time_slice = NULL,
  band = NULL,
  product = NULL,
  masking = "center",
  timestamp = NULL
)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-RasterDB-insert_RasterLayer"></a>}}
\if{latex}{\out{\hypertarget{method-RasterDB-insert_RasterLayer}{}}}
\subsection{Method \code{insert_RasterLayer()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{RasterDB$insert_RasterLayer(
  r,
  time_slice = NULL,
  band = 1,
  band_title = NULL,
  flush = TRUE,
  update_pyramid = TRUE,
  refresh_meta = TRUE,
  timestamp = NULL
)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-RasterDB-insert_RasterStack"></a>}}
\if{latex}{\out{\hypertarget{method-RasterDB-insert_RasterStack}{}}}
\subsection{Method \code{insert_RasterStack()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{RasterDB$insert_RasterStack(
  r,
  time_slice = NULL,
  bands = NULL,
  flush = TRUE,
  update_pyramid = TRUE,
  refresh_meta = TRUE,
  timestamp = NULL
)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-RasterDB-rebuild_pyramid"></a>}}
\if{latex}{\out{\hypertarget{method-RasterDB-rebuild_pyramid}{}}}
\subsection{Method \code{rebuild_pyramid()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{RasterDB$rebuild_pyramid()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-RasterDB-update_pyramid"></a>}}
\if{latex}{\out{\hypertarget{method-RasterDB-update_pyramid}{}}}
\subsection{Method \code{update_pyramid()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{RasterDB$update_pyramid()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-RasterDB-set_meta"></a>}}
\if{latex}{\out{\hypertarget{method-RasterDB-set_meta}{}}}
\subsection{Method \code{set_meta()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{RasterDB$set_meta(meta)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-RasterDB-set_band_meta"></a>}}
\if{latex}{\out{\hypertarget{method-RasterDB-set_band_meta}{}}}
\subsection{Method \code{set_band_meta()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{RasterDB$set_band_meta(bands)}\if{html}{\out{</div>}}
}

}
}
