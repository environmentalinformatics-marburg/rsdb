% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/PointCloud.R
\name{PointCloud}
\alias{PointCloud}
\title{PointCloud class}
\format{
PointCloud \link{R6Class} object.
}
\usage{
# connect to remote sensing database
remotesensing <- RemoteSensing$new(url, userpwd=NULL)

# open one pointcloud in connected remote sensing database
pointcloud <- remotesensing$pointcloud(name)

# operate on opened pointcloud:

pointcloud$points(ext, columns=NULL, filter=NULL, normalise=NULL, time_slice_id=NULL, time_slice_name=NULL)
pointcloud$raster(ext, res=1, type="point_count", fill=10, time_slice_id=NULL, time_slice_name=NULL)
pointcloud$volume(ext, res=1, zres=res, time_slice_id=NULL, time_slice_name=NULL)
pointcloud$indices(areas, functions, omit_empty_areas=TRUE, time_slice_id=NULL, time_slice_name=NULL)

pointcloud$name
pointcloud$meta
pointcloud$geocode
pointcloud$proj4
pointcloud$extent
pointcloud$description
pointcloud$raster_list
pointcloud$attribute_list
pointcloud$index_list
pointcloud$time_slices
}
\description{
PointCloud class provides methods to access (LiDAR) point-clouds of Remote Sensing Database.
}
\section{Details}{


In the Following methods of PointCloud are described. Use instance objects to call that methods (e.g. pointcloud$method(paramters) ).
Use instance of \link{RemoteSensing} class to create instances of PointCloud.

\describe{

\item{$points(ext, columns=NULL, filter=NULL, normalise=NULL, time_slice_id=NULL, time_slice_name=NULL)}{Get pointcloud points.

returns: data.frame

parameters:

\strong{ext}: subset of pointcloud.

ext is of type 'bbox' or 'Extent' (rectangular area) or 'Polygon' (polygon area, see \link{convert_Polygon_to_matrix}) or 'polygons' (polygon area, see \link{convert_Polygons_to_matrix}) or 'Matrix' (polygon area, two columns (x,y) and one row per point, first and last point need to be same for closed polygons).

\strong{columns}: requested attributes.

Vector of column-names. See "$attribute_list" for available attributes.

\strong{filter}: point filter.

Vector of conjunctive connected filter elements:

'ground' Ground classified points only.

'vegetation' Vegetation classified points only.

'non_ground' All not ground classified points.

'non_vegetation' All not vegetation classified points.

'classification=x' e.g. 'classification=1' Points of that classification only.

'return=x' e.g. 'return=1' Points of that return only.

'last_return=x' e.g. 'last_return=1' Points of that last_return only (returns counted in reverse beginning with last).

\strong{normalise}: point normalisation.

\itemize{

 \item \strong{\code{"extremes"}}

 removes points that are outliers in z resp. elevation coordinate

 \item \strong{\code{"ground"}}

 moves z resp. elevation coordinate of LiDAR points to elevation zero. The resulting z coordinates represent vegetation above ground.

}

Multiple Normalisations may be combined by list of characters or by comma separated character. e.g. \code{"extremes,ground"} or \code{list("extremes","ground")}

}

\item{$raster(ext, res=1, type="point_count", fill=10, time_slice_id=NULL, time_slice_name=NULL)}{Process pointcloud to raster.

returns: RasterLayer

parameters:

\strong{ext}: subset of pointcloud.

ext is of type 'bbox' or 'Extent' (rectangular area).

\strong{res}: pixel size of raster.

\strong{type}: type of raster processing.

For available types see "$raster_list".

\strong{fill}: if pixel value is missing fill it with nearest pixels of at most given pixel count distance.

}

\item{$volume(ext, res=1, zres=res, time_slice_id=NULL, time_slice_name=NULL)}{Process pointcloud to voxels (multiple layers of rasters).

returns: RasterStack

parameters:

\strong{ext}: subset of pointcloud.

ext is of type 'bbox' or 'Extent' (rectangular area).

\strong{res}: pixel (voxel) size of raster.

\strong{zres}: height of voxel (height per layer)

}

\item{$indices(areas, functions, omit_empty_areas=TRUE, time_slice_id=NULL, time_slice_name=NULL)}{calculate metrices at areas.

returns: data.frame

parameters:

\strong{areas}: areas is of type

 'SpatialPolygons' (several polygon areas) Polygons are extracted with IDs as names. See details of conversion in \link{convert_SpatialPolygons_to_named_matrix_list}

 'SpatialPolygonsDataFrame' (several polygon areas) Polygons are extracted with IDs as names. See details of conversion in \link{convert_SpatialPolygonsDataFrame_to_named_matrix_list}

 or one area or list of following types:

'bbox' or 'Extent' (one rectangular area) Polygons are extracted as rectangles and with names (if list elements are named)

'Polygon' (one polygon area) Polygons are extracted with names (if list elements are named). . See details of conversion in \link{convert_Polygon_to_matrix}

'Polygons' (one polygon area) Polygons are extracted with names (if list elements are named). . See details of conversion in \link{convert_Polygons_to_matrix}

'Matrix' (one polygon area) Polygons are extracted as polygons and with names (if list elements are named), matrix of two columns (x,y) and one row per point, first and last point need to be same for closed polygons.


If list entries are named (e.g. list(name1=ext1, name2=ext2) ) then the returned data.fram contains that names in a 'name'-column.

\strong{functions}: one or a list of index names.

For available index names see "$index_list".

\strong{omit_empty_areas}: Don't include areas with no point data in result (default).

}

\item{$name}{get name of pointcloud}

\item{$meta}{get meta data}

\item{$geocode}{get geo code (e.g. EPSG code)}

\item{$proj4}{get projection as PROJ4}

\item{$extent}{get full extent of pointcloud as 'Extent' object.

Note: Do not use this full extent to request data as the full pointcloud may be several gigabytes large!}

\item{$description}{get textual description}

\item{$raster_list}{get names of available raster processing types, that can be reqested by "$raster" function.}

\item{$attribute_list}{get names of point attributes (x, y, z, intensity, etc.), that are available in this pointcloud.}

\item{$index_list}{get names and description of LiDAR indieces, that can be requested by "$indices" function.}

}
}

\section{Extent objects}{


An Extent (in 'raster'-package) is a rectangle, parallel to the coordinate system axes.

It can be directlty created by \code{extent(...)}

or based on position and diameter \code{extent_diameter(x, y, d)}

Alternativly objects of class 'bbox' (in 'sf'-package) can be used.
}

\section{Polygon objects}{


A Polygon (in 'sp'-package) is a closed sequence of points that cover an area. First and last point of the sequence need to be same.

Manual creation of a Polygon
\preformatted{
# create Matrix of point seqence
x <- 477662.863 + c(1,2,1.5,1,1)
y <- 5632129.623 + c(1,1,2.7,2,1)
coords <- cbind(x, y)

# create Polygon from Matrix
p <- Polygon(coords=coords)
}

Create Polygon from database ROI
\preformatted{
roi <- remotesensing$roi(group_name="hai", roi_name="HEW02")
p <- Polygon(coords=roi$polygon)
}

Convert Polygon to Extent (bounding box)
\preformatted{
x <- p@coords[,1]
y <- p@coords[,2]
ext <- raster::extent(x=min(x), xmax=max(x), ymin=min(y), ymax=max(y))
}
}

\examples{

# open remote sensing database
library(RSDB)
#remotesensing <- RemoteSensing$new("http://localhost:8081", "user:password") # local
remotesensing <- RemoteSensing$new("http://example.com:8081", "user:password") # remote server

# get pointcloud names
remotesensing$pointclouds

# open pointcloud
pointcloud <- remotesensing$pointcloud("jannik_uniwald_sequoia")

# get projection as proj4
pointcloud$proj4

#create position
pos <- c(477662.863, 5632129.623)

# create extent at position and diameter of 10 meter
ext <- extent_diameter(x=pos[1], y=pos[2], 10)

# get data.frame of points in extent
df <- pointcloud$points(ext, columns=c("x", "y", "z", "classification", "returns"))

# get raster of DSM at 0.5 meter resolution
r <- pointcloud$raster(ext, res=0.5,  type="dsm", fill=10)
plot(r)
visualise_raster(r)

#calculate all indices for ext and name ext as 'e1'
df <- pointcloud$indices(list(e1=ext), pointcloud$index_list$name)

}
\seealso{
\link{RemoteSensing} \link{extent} \link{Polygon} \link{extent_diameter} \link{extent_radius} \link{RasterLayer-class} \link{visualise_raster}
}
\author{
woellauer
}
\keyword{LiDAR}
\keyword{database}
\keyword{point}
\keyword{point-cloud}
\keyword{remote-sensing}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-PointCloud-new}{\code{PointCloud$new()}}
\item \href{#method-PointCloud-points}{\code{PointCloud$points()}}
\item \href{#method-PointCloud-raster}{\code{PointCloud$raster()}}
\item \href{#method-PointCloud-volume}{\code{PointCloud$volume()}}
\item \href{#method-PointCloud-indices}{\code{PointCloud$indices()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PointCloud-new"></a>}}
\if{latex}{\out{\hypertarget{method-PointCloud-new}{}}}
\subsection{Method \code{new()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PointCloud$new(base_url, name, curlHandle, rsdbConnector)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PointCloud-points"></a>}}
\if{latex}{\out{\hypertarget{method-PointCloud-points}{}}}
\subsection{Method \code{points()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PointCloud$points(
  ext,
  columns = NULL,
  filter = NULL,
  normalise = NULL,
  time_slice_id = NULL,
  time_slice_name = NULL
)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PointCloud-raster"></a>}}
\if{latex}{\out{\hypertarget{method-PointCloud-raster}{}}}
\subsection{Method \code{raster()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PointCloud$raster(
  ext,
  res = 1,
  type = "point_count",
  fill = 10,
  time_slice_id = NULL,
  time_slice_name = NULL
)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PointCloud-volume"></a>}}
\if{latex}{\out{\hypertarget{method-PointCloud-volume}{}}}
\subsection{Method \code{volume()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PointCloud$volume(
  ext,
  res = 1,
  zres = res,
  time_slice_id = NULL,
  time_slice_name = NULL
)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PointCloud-indices"></a>}}
\if{latex}{\out{\hypertarget{method-PointCloud-indices}{}}}
\subsection{Method \code{indices()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PointCloud$indices(
  areas,
  functions,
  omit_empty_areas = TRUE,
  time_slice_id = NULL,
  time_slice_name = NULL
)}\if{html}{\out{</div>}}
}

}
}
