% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/PointCloud.R
\name{PointCloud}
\alias{PointCloud}
\title{PointCloud class}
\format{
PointCloud \link{R6Class} object.
}
\usage{
# connect to remote sensing database
remotesensing <- RemoteSensing$new(url, userpwd=NULL)

# open one pointcloud in connected remote sensing database
pointcloud <- remotesensing$pointcloud(name)

# operate on opened pointcloud:

pointcloud$points(ext, columns=NULL, filter=NULL, normalise=NULL, time_slice_id=NULL, time_slice_name=NULL)
pointcloud$raster(ext, res=1, type="point_count", fill=10, time_slice_id=NULL, time_slice_name=NULL)
pointcloud$volume(ext, res=1, zres=res, time_slice_id=NULL, time_slice_name=NULL)
pointcloud$indices(areas, functions, omit_empty_areas=TRUE, time_slice_id=NULL, time_slice_name=NULL)
pointcloud$set_meta(meta)

pointcloud$name
pointcloud$meta
pointcloud$geocode
pointcloud$proj4
pointcloud$extent
pointcloud$description
pointcloud$raster_list
pointcloud$attribute_list
pointcloud$index_list
pointcloud$time_slices
}
\description{
PointCloud class provides methods to access (LiDAR) point-clouds of Remote Sensing Database.

Use instance of \link{RemoteSensing} class to create instances of PointCloud class.

In section 'Active bindings' class fields and in section 'Methods' class functions of pointcloud class are described.

Use instance objects of PointCloud class to call that functionality (e.g. pointcloud$name ).
}
\section{Extent objects}{


An Extent (in 'raster'-package) is a rectangle, parallel to the coordinate system axes.

It can be directlty created by \code{extent(...)}

or based on position and diameter \code{extent_diameter(x, y, d)}

Alternativly objects of class 'bbox' (in 'sf'-package) can be used.
}

\section{Polygon objects}{


A Polygon (in 'sp'-package) is a closed sequence of points that cover an area. First and last point of the sequence need to be same.

Manual creation of a Polygon
\preformatted{
# create Matrix of point seqence
x <- 477662.863 + c(1,2,1.5,1,1)
y <- 5632129.623 + c(1,1,2.7,2,1)
coords <- cbind(x, y)

# create Polygon from Matrix
p <- Polygon(coords=coords)
}

Create Polygon from database ROI
\preformatted{
roi <- remotesensing$roi(group_name="hai", roi_name="HEW02")
p <- Polygon(coords=roi$polygon)
}

Convert Polygon to Extent (bounding box)
\preformatted{
x <- p@coords[,1]
y <- p@coords[,2]
ext <- raster::extent(x=min(x), xmax=max(x), ymin=min(y), ymax=max(y))
}
}

\examples{

# open remote sensing database
library(RSDB)
#remotesensing <- RemoteSensing$new("http://localhost:8081", "user:password") # local
remotesensing <- RemoteSensing$new("http://example.com:8081", "user:password") # remote server

# get pointcloud names
remotesensing$pointclouds

# open pointcloud
pointcloud <- remotesensing$pointcloud("jannik_uniwald_sequoia")

# get projection as proj4
pointcloud$proj4

#create position
pos <- c(477662.863, 5632129.623)

# create extent at position and diameter of 10 meter
ext <- extent_diameter(x=pos[1], y=pos[2], 10)

# get data.frame of points in extent
df <- pointcloud$points(ext, columns=c("x", "y", "z", "classification", "returns"))

# get raster of DSM at 0.5 meter resolution
r <- pointcloud$raster(ext, res=0.5,  type="dsm", fill=10)
plot(r)
visualise_raster(r)

#calculate all indices for ext and name ext as 'e1'
df <- pointcloud$indices(list(e1=ext), pointcloud$index_list$name)

}
\seealso{
\link{RemoteSensing} \link{extent} \link{Polygon} \link{extent_diameter} \link{extent_radius} \link{RasterLayer-class} \link{visualise_raster}
}
\author{
woellauer
}
\keyword{LiDAR}
\keyword{database}
\keyword{point}
\keyword{point-cloud}
\keyword{remote-sensing}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{name}}{Pointcloud name.}

\item{\code{meta}}{Meta data.}

\item{\code{geocode}}{Geo code (e.g. EPSG code).}

\item{\code{proj4}}{Pointcloud Projection as PROJ4.}

\item{\code{extent}}{Full extent of pointcloud as 'Extent' object. Note: Do not use this full extent to request data as the full pointcloud may be many gigabytes large!}

\item{\code{description}}{Textual pointcloud data description.}

\item{\code{raster_list}}{Names of available raster processing types, that can be requested by "$raster()" method.}

\item{\code{attribute_list}}{Names of point attributes (x, y, z, intensity, etc.), that are available in this pointcloud.}

\item{\code{index_list}}{Names and description of LiDAR indices, that can be requested by "$indices()" method.}

\item{\code{time_slices}}{List of all time slices in this pointcloud.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-PointCloud-new}{\code{PointCloud$new()}}
\item \href{#method-PointCloud-points}{\code{PointCloud$points()}}
\item \href{#method-PointCloud-raster}{\code{PointCloud$raster()}}
\item \href{#method-PointCloud-volume}{\code{PointCloud$volume()}}
\item \href{#method-PointCloud-indices}{\code{PointCloud$indices()}}
\item \href{#method-PointCloud-set_meta}{\code{PointCloud$set_meta()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PointCloud-new"></a>}}
\if{latex}{\out{\hypertarget{method-PointCloud-new}{}}}
\subsection{Method \code{new()}}{
Use instance of \link{RemoteSensing} class to create instances of PointCloud class.
This initialize function is for internal use only.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PointCloud$new(base_url, name, curlHandle, rsdbConnector)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{base_url}}{RSDB server URL.}

\item{\code{name}}{Pointcloud name.}

\item{\code{curlHandle}}{connection handler.}

\item{\code{rsdbConnector}}{rsdb server connection.}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PointCloud-points"></a>}}
\if{latex}{\out{\hypertarget{method-PointCloud-points}{}}}
\subsection{Method \code{points()}}{
Retrieve subsets of pointcloud points.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PointCloud$points(
  ext,
  columns = NULL,
  filter = NULL,
  normalise = NULL,
  time_slice_id = NULL,
  time_slice_name = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{ext}}{Subset of pointcloud.

ext is of type 'bbox' or 'Extent' (rectangular area) or 'Polygon' (polygon area, see \link{convert_Polygon_to_matrix}) or 'polygons' (polygon area, see \link{convert_Polygons_to_matrix}) or 'Matrix' (polygon area, two columns (x,y) and one row per point, first and last point need to be same for closed polygons).}

\item{\code{columns}}{Requested attributes.

Vector of column-names. See "$attribute_list" for available attributes.}

\item{\code{filter}}{Point filter.

Vector of conjunctive connected filter elements:

\itemize{
\item \strong{'ground'} Ground classified points only.
\item \strong{'vegetation'} Vegetation classified points only
\item \strong{'non_ground'} All not ground classified points.
\item \strong{'non_vegetation'} All not vegetation classified points.
\item \strong{'classification=x'} e.g. 'classification=1' Points of that classification only.
\item \strong{'return=x'} e.g. 'return=1' Points of that return only.
\item \strong{'last_return=x'} e.g. 'last_return=1' Points of that last_return only (returns counted in reverse beginning with last).
}}

\item{\code{normalise}}{(deprecated) Point normalisation.

\itemize{
\item \strong{'extremes'} Removes points that are outliers in z resp. elevation coordinate.
\item \strong{'ground'} Moves z resp. elevation coordinate of LiDAR points to elevation zero. The resulting z coordinates represent vegetation above ground.
}

Multiple Normalisations may be combined by list of characters or by comma separated character. e.g. \code{"extremes,ground"} or \code{list("extremes","ground")}}

\item{\code{time_slice_id}}{Optionally, get points of specified time slice id.}

\item{\code{time_slice_name}}{Optionally, get points of specified time slice name.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
data.frame of points.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PointCloud-raster"></a>}}
\if{latex}{\out{\hypertarget{method-PointCloud-raster}{}}}
\subsection{Method \code{raster()}}{
Process pointcloud to raster.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PointCloud$raster(
  ext,
  res = 1,
  type = "point_count",
  fill = 10,
  time_slice_id = NULL,
  time_slice_name = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{ext}}{Subset of pointcloud.

ext is of type 'bbox' or 'Extent' (rectangular area).}

\item{\code{res}}{Pixel size of raster.}

\item{\code{type}}{Type of raster processing.

For a complete list of available types see "$raster_list". Most used types are 'dsm', 'dtm', 'chm'.}

\item{\code{fill}}{If pixel value is missing, fill it with nearest pixels of at most given pixel count distance.}

\item{\code{time_slice_id}}{Optionally, process specified time slice id.}

\item{\code{time_slice_name}}{Optionally, process specified time slice name.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
RasterLayer
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PointCloud-volume"></a>}}
\if{latex}{\out{\hypertarget{method-PointCloud-volume}{}}}
\subsection{Method \code{volume()}}{
Process pointcloud to voxels (multiple layers of rasters).
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PointCloud$volume(
  ext,
  res = 1,
  zres = res,
  time_slice_id = NULL,
  time_slice_name = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{ext}}{Subset of pointcloud.

ext is of type 'bbox' or 'Extent' (rectangular area).}

\item{\code{res}}{Pixel (voxel) size of raster.}

\item{\code{zres}}{Height of voxel (height per layer).}

\item{\code{time_slice_id}}{Optionally, process specified time slice id.}

\item{\code{time_slice_name}}{Optionally, process specified time slice name.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
RasterStack
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PointCloud-indices"></a>}}
\if{latex}{\out{\hypertarget{method-PointCloud-indices}{}}}
\subsection{Method \code{indices()}}{
Calculate metrices at areas.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PointCloud$indices(
  areas,
  functions,
  omit_empty_areas = TRUE,
  time_slice_id = NULL,
  time_slice_name = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{areas}}{Areas is of type:

 'SpatialPolygons' (several polygon areas) Polygons are extracted with IDs as names. See details of conversion in \link{convert_SpatialPolygons_to_named_matrix_list}

 'SpatialPolygonsDataFrame' (several polygon areas) Polygons are extracted with IDs as names. See details of conversion in \link{convert_SpatialPolygonsDataFrame_to_named_matrix_list}

 or one area or list of following types:

'bbox' or 'Extent' (one rectangular area) Polygons are extracted as rectangles and with names (if list elements are named)

'Polygon' (one polygon area) Polygons are extracted with names (if list elements are named). . See details of conversion in \link{convert_Polygon_to_matrix}

'Polygons' (one polygon area) Polygons are extracted with names (if list elements are named). . See details of conversion in \link{convert_Polygons_to_matrix}

'Matrix' (one polygon area) Polygons are extracted as polygons and with names (if list elements are named), matrix of two columns (x,y) and one row per point, first and last point need to be same for closed polygons.


If list entries are named (e.g. list(name1=ext1, name2=ext2) ) then the returned data.fram contains that names in a 'name'-column.}

\item{\code{functions}}{One index name or a list of index names.

For available index names see "$index_list".}

\item{\code{omit_empty_areas}}{Don't include areas with no point data in result (default).}

\item{\code{time_slice_id}}{Optionally, process specified time slice id.}

\item{\code{time_slice_name}}{Optionally, process specified time slice name.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
data.frame
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PointCloud-set_meta"></a>}}
\if{latex}{\out{\hypertarget{method-PointCloud-set_meta}{}}}
\subsection{Method \code{set_meta()}}{
Change meta data of this pointcloud layer
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PointCloud$set_meta(meta)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{meta}}{Named list of meta data entries to be set. Named entries can be:
title, description, corresponding_contact, acquisition_date, code, proj4,
acl, acl_mod, acl_owner, tags, associated, properties}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
result
}
}
}
